<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="MlAWwzcGEsG8nn2V34gojElRFcnHeEgBvIS8Ek1LQ0c"><meta name="msvalidate.01" content="8BDA269F1F25AB9AB2160E377B2334C5"><link rel="alternate" type="application/rss+xml" title="Follow your heart" href="http://mingcheng.site/rss.xml"><link rel="alternate" type="application/atom+xml" title="Follow your heart" href="http://mingcheng.site/atom.xml"><link rel="alternate" type="application/json" title="Follow your heart" href="http://mingcheng.site/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="java"><link rel="canonical" href="http://mingcheng.site/learn/java/core-java/learn-4/"><title>原书笔记（卷一 第 4 章） - Java 核心技术卷 (第 10 版) - Java 语言学习 - 学习 | Jalen's Blog = Follow your heart = A happy life</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">原书笔记（卷一 第 4 章）</h1><div class="meta"><span class="item" title="创建时间：2021-07-24 23:40:28"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-07-24T23:40:28+08:00">2021-07-24</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>13k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>11 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jalen's Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2023/01/05/Iopz7v9tlHxFuQR.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/01/05/eGlSTz1jtbm8YW7.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/01/05/Po4mLwakGNrFTxX.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/01/05/ZgfTDNd72ECIoRz.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/01/05/ltAiNoEJ9HG1PBc.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/01/05/68FSYUqVxELJ7kG.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/learn/" itemprop="item" rel="index" title="分类于 学习"><span itemprop="name">学习</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/learn/Java-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" itemprop="item" rel="index" title="分类于 Java 语言学习"><span itemprop="name">Java 语言学习</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/learn/java/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7-%E7%AC%AC10%E7%89%88/" itemprop="item" rel="index" title="分类于 Java 核心技术卷 (第 10 版)"><span itemprop="name">Java 核心技术卷 (第 10 版)</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://mingcheng.site/learn/java/core-java/learn-4/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Jalen Chu"><meta itemprop="description" content="A happy life, ٩(●˙▿˙●)۶…⋆ฺ ->"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Follow your heart"></span><div class="body md" itemprop="articleBody"><h1 id="第4章-java程序设计概述"><a class="anchor" href="#第4章-java程序设计概述">#</a> 第 4 章　Java 程序设计概述</h1><h2 id="41-面向对象程序设计概述"><a class="anchor" href="#41-面向对象程序设计概述">#</a> 4.1 面向对象程序设计概述</h2><p>1. 面向对象程序设计（简称 OOP）是当今主流的程序设计范型，它已经取代了 20 世纪 70 年代的 “结构化” 过程化程序设计开发技术。Java 是完全面向对象的。</p><p>2. 传统的结构化程序设计通过设计一系列的过程（即算法）来求解问题。一旦确定了这些过程，就要开始考虑存储数据的方式。这就是 Pascal 语言的设计者 Niklaus Wirth 将其著作命名为《算法 + 数据结构 = 程序》（Algorithms+Data Structures=Programs，Prentice Hall，1975）的原因。需要注意的是，在 Wirth 命名的书名中，算法是第一位的，数据结构是第二位的，这就明确地表述了程序员的工作方式。首先要确定如何操作数据，然后再决定如何组织数据，以便于数据操作。而 OOP 却调换了这个次序，将数据放在第一位，然后再考虑操作数据的算法。</p><p>3. 注意面向过程和面向对象的区别。</p><h3 id="411-类"><a class="anchor" href="#411-类">#</a> 4.1.1 类</h3><p>1. 正如前面所看到的，用 Java 编写的所有代码都位于某个类的内部。标准的 Java 库提供了几千个类，可以用于用户界面设计、日期、日历和网络程序设计。尽管如此，还是需要在 Java 程序中创建一些自己的类，以便描述应用程序所对应的问题域中的对象。</p><p>2. 封装（encapsulation，有时称为数据隐藏）是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。对象中的数据称为实例域（instance field），操纵数据的过程称为方法（method）。对于每个特定的类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前状态（state）。无论何时，只要向对象发送一个消息，它的状态就有可能发生改变。封装给对象赋予了 “黑盒” 特征，这是提高重用性和可靠性的关键。</p><p>3.OOP 的另一个原则会让用户自定义 Java 类变得轻而易举，这就是：可以通过扩展一个类来建立另外一个新的类。事实上，在 Java 中，所有的类都源自于一个 “神通广大的超类”，它就是 Object。在扩展一个已有的类时，这个扩展后的新类具有所扩展的类的全部属性和方法。在新类中，只需提供适用于这个新类的新方法和数据域就可以了。通过扩展一个类来建立另外一个类的过程称为继承（inheritance）。</p><h3 id="412-对象"><a class="anchor" href="#412-对象">#</a> 4.1.2 对象</h3><p>1.OOP 中对象的三个主要特性：</p><ul><li>对象的行为（behavior）—— 可以对对象施加哪些操作，或可以对对象施加哪些方法？</li><li>对象的状态（state）—— 当施加那些方法时，对象如何响应？</li><li>对象标识（identity）—— 如何辨别具有相同行为与状态的不同对象？</li></ul><h3 id="413-识别类"><a class="anchor" href="#413-识别类">#</a> 4.1.3 识别类</h3><p>1. 首先从设计类开始，然后再往每个类中添加方法。</p><p>2. 识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。</p><h3 id="414-类之间的关系"><a class="anchor" href="#414-类之间的关系">#</a> 4.1.4 类之间的关系</h3><p>1. 类之间最常见的关系有：</p><ul><li>依赖（“uses-a”）</li><li>聚合（“has-a”）</li><li>继承（“is-a”）</li></ul><p>2. 依赖（dependence）：即 “uses-a” 关系，是一种最明显的、最常见的关系。例如，Order 类使用 Account 类是因为 Order 对象需要访问 Account 对象查看信用状态。但是 Item 类不依赖于 Account 类，这是因为 Item 对象与客户账户无关。</p><p>3. 解耦：应该尽可能地将相互依赖的类减至最少。如果类 A 不知道 B 的存在，它就不会关心 B 的任何改变（这意味着 B 的改变不会导致 A 产生任何 bug）。用软件工程的术语来说，就是让类之间的耦合度最小。</p><p>4. 聚合（aggregation）：即 “has-a” 关系，是一种具体且易于理解的关系。例如，一个 Order 对象包含一些 Item 对象。聚合关系意味着类 A 的对象包含类 B 的对象。</p><p>5. 继承（inheritance）：即 “is-a” 关系，是一种用于表示特殊与一般关系的。例如，Rush Order 类由 Order 类继承而来。在具有特殊性的 RushOrder 类中包含了一些用于优先处理的特殊方法，以及一个计算运费的不同方法；而其他的方法，如添加商品、生成账单等都是从 Order 类继承来的。一般而言，如果类 A 扩展类 B，类 A 不但包含从类 B 继承的方法，还会拥有一些额外的功能。</p><p>6.UML 类图，注意类之前关系以及相对应关系应当使用的 UML 连接符。</p><h2 id="42-使用预定义类"><a class="anchor" href="#42-使用预定义类">#</a> 4.2 使用预定义类</h2><p>1. 在 Java 中，没有类就无法做任何事情，然而，并不是所有的类都具有面向对象特征。例如，Math 类。Math 类只封装了功能，它不需要也不必隐藏数据。还有 Date 类。</p><h3 id="421-对象与对象变量"><a class="anchor" href="#421-对象与对象变量">#</a> 4.2.1 对象与对象变量</h3><p>1. 要想使用对象，就必须首先构造对象，并指定其初始状态。然后，对对象应用方法。</p><p>2. 在 Java 中，使用构造器（constructor）构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。构造器的名字应该与类名相同。</p><p>3.Java 为什么用类描述时间而不是像其他语言那样使用一个内置的（build-in）类型？（Java 的日期类库有些混乱，已经重新设计了两次）</p><p>4. 一定要认识到：一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。在 Java 中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new 操作符的返回值也是一个引用。可以显式地将对象变量设置为 null，表明这个对象变量目前没有引用任何对象（在 C<ins> 中没有空引用，并且引用不能被赋值。可以将 Java 的对象变量看作 C</ins> 的对象指针。）。所有的 Java 对象都存储在堆中。当一个对象包含另一个对象变量时，这个变量依然包含着指向另一个堆对象的指针。</p><p>5. 在 Java 中，必须使用 clone 方法获得对象的完整拷贝。</p><h3 id="422-java类库中的localdate类"><a class="anchor" href="#422-java类库中的localdate类">#</a> 4.2.2 Java 类库中的 LocalDate 类</h3><p>1.Date 类的实例有一个状态，即特定的时间点。尽管在使用 Date 类时不必知道这一点，但时间是用距离一个固定时间点的毫秒数（可正可负）表示的，这个点就是所谓的纪元（epoch），它是 UTC 时间 1970 年 1 月 1 日 00：00：00。UTC 是 Coordinated Universal Time 的缩写，与大家熟悉的 GMT（即 Greenwich Mean Time，格林威治时间）一样，是一种具有实践意义的科学标准时间。 但是，Date 类所提供的日期处理并没有太大的用途。Java 类库的设计者认为：像 “December 31，1999，23：59：59” 这样的日期表示法只是阳历的固有习惯。这种特定的描述法遵循了世界上大多数地区使用的 Gregorian 阳历表示法。但是，同一时间点采用中国的农历表示和采用希伯来的阴历表示就很不一样，对于火星历来说就更不可想象了。类库设计者决定将保存时间与给时间点命名分开。所以标准 Java 类库分别包含了两个类：一个是用来表示时间点的 Date 类；另一个是用来表示大家熟悉的日历表示法的 LocalDate 类。Java SE 8 引入了另外一些类来处理日期和时间的不同方面。将时间与日历分开是一种很好的面向对象设计。通常，最好使用不同的类表示不同的概念。</p><p>2.LocalDate 对象，可以用方法 getYear、getMonthValue 和 getDayOfMonth 得到年、月和日。实际上，Date 类（from jdk1.0）还有 getDay、getMonth 以及 getYear 等方法，然而并不推荐使用这些方法（类库设计者意识到应当单独提供类来处理日历，已被标注为 @Deprecated）。</p><h3 id="423-更改器方法和访问器方法"><a class="anchor" href="#423-更改器方法和访问器方法">#</a> 4.2.3 更改器方法和访问器方法</h3><p>1. 只访问对象而不修改对象的方法有时称为访问器方法（accessor method）。例如，LocalDate.getYear 和 GregorianCalendar.get 就是访问器方法。</p><p>2. 相反，访问对象并修改对象的属性的方法称为更改器方法。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">strictfp</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token class-name">LocalDate</span> now1 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">LocalDate</span> aThousandYearLater <span class="token operator">=</span> now1<span class="token punctuation">.</span><span class="token function">plusDays</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>now1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2021-07-24</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aThousandYearLater<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2024-04-19</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">GregorianCalendar</span> now2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GregorianCalendar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        now2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span><span class="token constant">DAY_OF_MONTH</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>now2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span><span class="token constant">YEAR</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2024</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 下面月份返回 3，日常人活中的月份都是从 1 开始计算的，而 Calendar 类从 0 开始算，</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 于是乎便解释了为何取出的月份比实际少 1</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 格里高利历和罗马儒略历中一年中的第一个月是 JANUARY，它为 0；最后一个月取决于一年中的月份数。</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>now2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span><span class="token constant">MONTH</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>now2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span><span class="token constant">DAY_OF_MONTH</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//19</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="用户自定义类"><a class="anchor" href="#用户自定义类">#</a> 用户自定义类</h2><h3 id="431-employee类"><a class="anchor" href="#431-employee类">#</a> 4.3.1 Employee 类</h3><p>1. 文件名必须与 public 类的名字相匹配。在一个源文件中，只能有一个公有类，但可以有任意数目的非公有类。</p><h3 id="432-多个源文件的使用"><a class="anchor" href="#432-多个源文件的使用">#</a> 4.3.2 多个源文件的使用</h3><p>1. 习惯于将每一个类存在一个单独的源文件中。</p><p>2. 当 Java 编译器发现 EmployeeTest.java 使用了 Employee 类时会查找名为 Employee.class 的文件。如果没有找到这个文件，就会自动地搜索 Employee.java，然后，对它进行编译。更重要的是：如果 Employee.java 版本较已有的 Employee.class 文件版本新，Java 编译器就会自动地重新编译这个文件。（无需显式编译 Employee.java）</p><h3 id="433-剖析employee类"><a class="anchor" href="#433-剖析employee类">#</a> 4.3.3 剖析 Employee 类</h3><p>1. 可以用 public 标记实例域，但这是一种极为不提倡的做法。public 数据域允许程序中的任何方法对其进行读取和修改。这就完全破坏了封装。任何类的任何方法都可以修改 public 域，从我们的经验来看，某些代码将使用这种存取权限，而这并不我们所希望的，因此，这里强烈建议将实例域标记为 private。</p><p>2. 类通常包括类型属于某个类类型的实例域（实例域可以本身就是对象）。</p><h3 id="434-从构造器开始"><a class="anchor" href="#434-从构造器开始">#</a> 4.3.4 从构造器开始</h3><p>1. 构造器与其他的方法有一个重要的不同。构造器总是伴随着 new 操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。</p><p>2. 特点</p><ul><li>构造器与类同名</li><li>每个类可以有一个以上的构造器</li><li>构造器可以有 0 个、1 个或多个参数</li><li>构造器没有返回值</li><li>构造器总是伴随着 new 操作一起调用（要记住所有的 Java 对象都是在堆中构造的）</li><li>如果一个类没有显式定义构造器，那么它会默认拥有一个无参构造器</li></ul><p>3. 请注意，不要在构造器中定义与实例域重名的局部变量。</p><h3 id="435-隐式参数与显式参数"><a class="anchor" href="#435-隐式参数与显式参数">#</a> 4.3.5 隐式参数与显式参数</h3><p>1. 显式参数是明显地列在方法声明中的，隐式参数没有出现在方法声明中。（有些人把隐式参数称为方法调用的目标或接收者。有些程序员偏爱用关键字 this 表示隐式参数，如 this.salary）</p><h3 id="436-封装的优点"><a class="anchor" href="#436-封装的优点">#</a> 4.3.6 封装的优点</h3><p>1.pojo 的 getter 方法都是典型的访问器方法。由于它们只返回实例域值，因此又称为域访问器。不要将实例域声明为 public，防止对实例域的破坏（破坏封装）。通常我们在设定一个 pojo 时需要遵循：</p><ul><li>一个私有的数据域（private xxx）</li><li>一个公有的域访问器方法（getter）</li><li>一个公有的域更改器方法（setter）</li></ul><p>2. 上述的优点</p><ul><li>更改内部实例不会影响外部其他代码</li><li>更改器方法可以执行错误检查，在实例域赋值时执行检查</li></ul><p>3. 注意不要编写返回引用可变对象的访问器方法。在 Employee 类中就违反了这个设计原则，其中的 getHireDay 方法返回了一个 Date 类对象。LocalDate 类没有更改器方法，与之不同，Date 类有一个更改器方法 setTime，可以在这里设置毫秒数。 Date 对象是可变的，这一点就破坏了封装性！出错的原因很微妙。d 和 harry.hireDay 引用同一个对象。对 d 调用更改器方法就可以自动地改变这个雇员对象的私有状态！(如果需要返回一个可变对象的引用，应当先对他进行克隆 - clone，并且实例域建议使用 LocalDate)</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">strictfp</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token class-name">Employee</span> harry <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">Date</span> d <span class="token operator">=</span> harry<span class="token punctuation">.</span><span class="token function">getHireDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">double</span> tenSeconds <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 下面对 d 的对象的改变会影响到 harry 实例域，</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 因为 d 和 harry.getHireDay 引用同一对象</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        d<span class="token punctuation">.</span><span class="token function">setTime</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> tenSeconds<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">Date</span> <span class="token function">getHireDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Date</span><span class="token punctuation">)</span> hireDay<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 解决方式之一，修改更改器方法</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="437-基于类的访问权限"><a class="anchor" href="#437-基于类的访问权限">#</a> 4.3.7 基于类的访问权限</h3><p>1. 方法可以访问所调用对象的私有数据。一个方法可以访问所属类的所有对象的私有数据，比如 equals 方法比较两个 Employee 对象名字是否相同，这是合法的。</p><h3 id="438-私有方法"><a class="anchor" href="#438-私有方法">#</a> 4.3.8 私有方法</h3><p>1. 在实现一个类时，由于公有数据非常危险，所以应该将所有的数据域都设置为私有的。而对于方法，尽管绝大多数方法都被设计为公有的，但在某些特殊情况下，也可能将它们设计为私有的。这可能是一个独立的辅助方法，通常，这些辅助方法不应该成为公有接口的一部分，这是由于它们往往与当前的实现机制非常紧密，或者需要一个特别的协议以及一个特别的调用次序。最好将这样的方法设计为 private 的。方便后续维护和删除（弃用）。</p><h3 id="439-final实例域"><a class="anchor" href="#439-final实例域">#</a> 4.3.9 final 实例域</h3><p>1. 可以将实例域定义为 final。构建对象时必须初始化这样的域。也就是说，必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。例如，可以将 Employee 类中的 name 域声明为 final，因为在对象构建之后，这个值不会再被修改，即没有 setName 方法。</p><p>2.final 修饰符大都应用于基本（primitive）类型域，或不可变（immutable）类的域（如果类中的每个方法都不会改变其对象，这种类就是不可变的类。例如，String 类就是一个不可变的类）。 对于可变的类，使用 final 修饰符可能会对读者造成混乱。</p><h2 id="44-静态域和静态方法"><a class="anchor" href="#44-静态域和静态方法">#</a> 4.4 静态域和静态方法</h2><h3 id="441-静态域"><a class="anchor" href="#441-静态域">#</a> 4.4.1 静态域</h3><p>1. 如果将域定义为 static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。在绝大多数的面向对象程序设计语言中，静态域被称为类域。</p><h3 id="442-静态常量"><a class="anchor" href="#442-静态常量">#</a> 4.4.2 静态常量</h3><p>1. 静态变量使用得比较少，但静态常量却使用得比较多。例如，在 Math 类中定义了一个静态常量 PI。如果关键字 static 被省略，PI 就变成了 Math 类的一个实例域。需要通过 Math 类的对象访问 PI，并且每一个 Math 对象都有它自己的一份 PI 拷贝。</p><p>2. 由于每个类对象都可以对公有域进行修改，所以，最好不要将域设计为 public。然而，公有常量（即 final 域）却没问题。</p><p>3. 如果查看一下 System 类，就会发现有一个 setOut 方法，它可以将 System.out 设置为不同的流。读者可能会感到奇怪，为什么这个方法可以修改 final 变量的值。原因在于，setOut 方法是一个本地方法，而不是用 Java 语言实现的。本地方法可以绕过 Java 语言的存取控制机制。这是一种特殊的方法，在自己编写程序时，不应该这样处理。</p><h3 id="443-静态方法"><a class="anchor" href="#443-静态方法">#</a> 4.4.3 静态方法</h3><p>1. 静态方法是一种不能向对象实施操作的方法。例如，Math 类的 pow 方法就是一个静态方法。在运算时不使用任何 Math 对象，换句话说就是没有隐式的参数。可以认为静态方法是没有 this 参数的方法（在一个非静态的方法中，this 参数表示这个方法的隐式参数）。</p><p>2. 但是，静态方法可以访问自身类中的静态域。（属于类且不属于类对象的变量和函数）</p><p>3. 可以使用对象调用静态方法。例如，如果 harry 是一个 Employee 对象，可以用 harry.getNextId（）代替 Employee.getNextId（）。不过，这种方式很容易造成混淆，其原因是 getNextId 方法计算的结果与 harry 毫无关系。我们建议使用类名，而不是对象来调用静态方法。</p><p>4. 下面两种情况下使用静态方法：</p><ul><li>一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow）。</li><li>一个方法只需要访问类的静态域（例如：Employee.getNextId）。</li></ul><h3 id="444-工厂方法"><a class="anchor" href="#444-工厂方法">#</a> 4.4.4 工厂方法</h3><p>1. 静态方法还有另外一种常见的用途。类似 LocalDate 和 NumberFormat 的类使用静态工厂方法（factory method）来构造对象。</p><h3 id="445-main方法"><a class="anchor" href="#445-main方法">#</a> 4.4.5 main 方法</h3><p>1.main 方法不对任何对象进行操作。事实上，在启动程序时还没有任何一个对象。静态的 main 方法将执行并创建程序所需要的对象。</p><p>2. 每一个类可以有一个 main 方法。这是一个常用于对类进行单元测试的技巧。</p><h2 id="方法参数"><a class="anchor" href="#方法参数">#</a> 方法参数</h2><p>1. 首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用（call by value）表示方法接收的是调用者提供的值。而按引用调用（call by reference）表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。“按…… 调用”（call by）是一个标准的计算机科学术语，它用来描述各种程序设计语言（不只是 Java）中方法参数的传递方式（事实上，以前还有按名调用（call by name），Algol 程序设计语言是最古老的高级程序设计语言之一，它使用的就是这种参数传递方式。不过，对于今天，这种传递方式已经成为历史）。</p><p>2.Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。</p><p>3. 方法参数共有两种类型： （1）基本数据类型（数字、布尔值）。 （2）对象引用。</p><p>4. 很多程序设计语言（特别是，C<ins> 和 Pascal）提供了两种参数传递的方式：值调用和引用调用（如 c</ins> 传参 &amp; 符号）。有些程序员（甚至本书的作者）认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。（可以以实际交换两个 Employee 对象为例）</p><p>5. 总结一下 Java 中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><h2 id="对象构造"><a class="anchor" href="#对象构造">#</a> 对象构造</h2><h3 id="461-重载"><a class="anchor" href="#461-重载">#</a> 4.6.1 重载</h3><p>1. 重载：如果多个方法（比如，StringBuilder 构造器方法）有相同的名字、不同的参数，便产生了重载。编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。如果编译器找不到匹配的参数，就会产生编译时错误，因为根本不存在匹配，或者没有一个比其他的更好。（这个过程被称为重载解析（overloading resolution）。）</p><p>2.Java 允许重载任何方法，而不只是构造器方法。因此，要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的签名（signature）。例如，String 类有 4 个称为 indexOf 的公有方法。它们的签名是</p><ul><li>indexOf(int)</li><li>indexOf(int, int)</li><li>indexOf(String)</li><li>indexOf(String, int)</li></ul><p>3. 返回类型不是方法签名的一部分。也就是说，不能有两个名字相同、参数类型也相同却返回不同类型值的方法。</p><h3 id="462-默认域初始化"><a class="anchor" href="#462-默认域初始化">#</a> 4.6.2 默认域初始化</h3><p>1. 如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值：数值为 0、布尔值为 false、对象引用为 null。然而，只有缺少程序设计经验的人才会这样做。确实，如果不明确地对域进行初始化，就会影响程序代码的可读性。</p><h3 id="463-无参数构造器"><a class="anchor" href="#463-无参数构造器">#</a> 4.6.3 无参数构造器</h3><p>1. 很多类都包含一个无参数的构造函数，对象由无参数构造函数创建时，其状态会设置为适当的默认值。</p><p>2. 如果在编写一个类时没有编写构造器，那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。于是，实例域中的数值型数据设置为 0、布尔型数据设置为 false、所有对象变量将设置为 null。</p><p>3. 如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时如果没有提供参数就会被视为不合法。</p><p>4. 请记住，仅当类没有提供任何构造器的时候，系统才会提供一个默认的构造器。如果在编写类的时候，给出了一个构造器，哪怕是很简单的，要想让这个类的用户能够无参构造实例，就必须提供一个默认的构造器（即不带参数的构造器）。</p><h3 id="464-显式域初始化"><a class="anchor" href="#464-显式域初始化">#</a> 4.6.4 显式域初始化</h3><p>1. 通过重载类的构造器方法，可以采用多种形式设置类的实例域的初始状态。确保不管怎样调用构造器，每个实例域都可以被设置为一个有意义的初值，这是一种很好的设计习惯。 可以在类定义中，直接将一个值赋给任何域。例如：</p><p>2. 在执行构造器之前，先执行赋值操作。当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时，这种方式特别有用。 初始值不一定是常量值。在下面的例子中，可以调用方法对域进行初始化。（在 C++ 中，不能直接初始化类的实例域。所有的域必须在构造器中设置。）</p><h3 id="465-参数名"><a class="anchor" href="#465-参数名">#</a> 4.6.5 参数名</h3><p>1. 参数变量用同样的名字将实例域屏蔽起来。例如，如果将参数命名为 salary，salary 将引用这个参数，而不是实例域。但是，可以采用 this.salary 的形式访问实例域。回想一下，this 指示隐式参数，也就是所构造的对象。</p><h3 id="466-调用另一个构造器"><a class="anchor" href="#466-调用另一个构造器">#</a> 4.6.6 调用另一个构造器</h3><p>1. 关键字 this 引用方法的隐式参数。然而，这个关键字还有另外一个含义。 如果构造器的第一个语句形如 this（...），这个构造器将调用同一个类的另一个构造器。采用这种方式使用 this 关键字非常有用，这样对公共的构造器代码部分只编写一次即可。</p><h3 id="467-初始化块"><a class="anchor" href="#467-初始化块">#</a> 4.6.7 初始化块</h3><p>1. 初始化数据域的方法</p><ul><li>在构造器中设置值</li><li>在声明中赋值</li><li>初始化块（initialization block）赋值</li></ul><p>2. 只要构造类的对象，这些块就会被执行。无论使用哪个构造器构造对象，都首先运行初始化块，然后才运行构造器的主体部分。这种机制不是必需的，也不常见。通常会直接将初始化代码放在构造器中。</p><p>3. 注释： 即使在类的后面定义，仍然可以在初始化块中设置域。但是，为了避免循环定义，不要读取在后面初始化的域。具体的规则请参看 Java 语言规范的 8.3.2.3 节（ <code>http://docs.oracle.com/javase/specs</code> ）。这个规则的复杂度足以使编译器的实现者头疼，因此建议将初始化块放在域定义之后。</p><p>4. 由于初始化数据域有多种途径，所以列出构造过程的所有路径可能相当混乱。下面是调用构造器的具体处理步骤：</p><ul><li>1）所有数据域被初始化为默认值（0、false 或 null）。</li><li>2）按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块。</li><li>3）如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。</li><li>4）执行这个构造器的主体。</li></ul><h3 id="468-对象析构与finalize方法"><a class="anchor" href="#468-对象析构与finalize方法">#</a> 4.6.8 对象析构与 finalize 方法</h3><p>1. 有些面向对象的程序设计语言，特别是 C++，有显式的析构器方法，其中放置一些当对象不再使用时需要执行的清理代码。在析构器中，最常见的操作是回收分配给对象的存储空间。由于 Java 有自动的垃圾回收器，不需要人工回收内存，所以 Java 不支持析构器。当然，某些对象使用了内存之外的其他资源，例如，文件或使用了系统资源的另一个对象的句柄。在这种情况下，当资源不再需要时，将其回收和再利用将显得十分重要。 可以为任何一个类添加 finalize 方法。finalize 方法将在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用 finalize 方法回收任何短缺的资源，这是因为很难知道这个方法什么时候才能够调用。</p><p>2. 有个名为 System.runFinalizersOnExit（true）的方法能够确保 finalizer 方法在 Java 关闭前被调用。不过，这个方法并不安全，也不鼓励大家使用。有一种代替的方法是使用方法 Runtime.addShutdownHook 添加 “关闭钩”（shutdown hook），如果某个资源需要在使用完毕后立刻被关闭，那么就需要由人工来管理。对象用完时，可以应用一个 close 方法来完成相应的清理操作。</p><h2 id="47-包"><a class="anchor" href="#47-包">#</a> 4.7 包</h2><p>1. 使用包的主要原因是确保类名的唯一性。假如两个程序员不约而同地建立了 Employee 类。只要将这些类放置在不同的包中，就不会产生冲突。事实上，为了保证包名的绝对唯一性，Sun 公司建议将公司的因特网域名（这显然是独一无二的）以逆序的形式作为包名，并且对于不同的项目使用不同的子包。例如，horstmann.com 是本书作者之一注册的域名。逆序形式为 com.horstmann。这个包还可以被进一步地划分成子包，如 com.horstmann.corejava。</p><h3 id="471-类的导入"><a class="anchor" href="#471-类的导入">#</a> 4.7.1 类的导入</h3><p>1. 一个类可以使用所属包中的所有类，以及其他包中的公有类（public class）。我们可以采用两种方式访问另一个包中的公有类。第一种方式是在每个类名之前添加完整的包名。还有一种是使用 import。</p><h3 id="472-静态导入"><a class="anchor" href="#472-静态导入">#</a> 4.7.2 静态导入</h3><p>1.import 语句不仅可以导入类，还增加了导入静态方法和静态域的功能。</p><h3 id="473-将类放入包中"><a class="anchor" href="#473-将类放入包中">#</a> 4.7.3 将类放入包中</h3><p>1. 要想将一个类放入包中，就必须将包的名字放在源文件的开头，包中定义类的代码之前。</p><p>2. 如果没有在源文件中放置 package 语句，这个源文件中的类就被放置在一个默认包（defaulf package）中。默认包是一个没有名字的包。</p><p>3. 需要注意，编译器对文件（带有文件分隔符和扩展名.java 的文件）进行操作。而 Java 解释器加载类（带有。分隔符）。</p><h3 id="474-包作用域"><a class="anchor" href="#474-包作用域">#</a> 4.7.4 包作用域</h3><p>1. 标记为 public 的部分可以被任意的类使用；标记为 private 的部分只能被定义它们的类使用。如果没有指定 public 或 private，这个部分（类、方法或变量）可以被同一个包中的所有方法访问。对于类来说，这种默认是合乎情理的。但是，对于变量来说就有些不适宜了，因此变量必须显式地标记为 private，不然的话将默认为包可见。显然，这样做会破坏封装性。问题主要出于人们经常忘记键入关键字 private。在 java.awt 包中的 Window 类就是一个典型的示例（反例，至今未更正）。</p><p>2. 从 1.2 版开始，JDK 的实现者修改了类加载器，明确地禁止加载用户自定义的、包名以 “java.” 开始的类！当然，用户自定义的类无法从这种保护中受益。然而，可以通过包密封（package sealing）机制来解决将各种包混杂在一起的问题。如果将一个包密封起来，就不能再向这个包添加类了。（如制作包含密封包的 JAR 文件）。</p><h3 id="48-类路径"><a class="anchor" href="#48-类路径">#</a> 4.8 类路径</h3><p>1. 在前面已经看到，类存储在文件系统的子目录中。类的路径必须与包名匹配。</p><p>2. 类文件也可以存储在 JAR（Java 归档）文件中。在一个 JAR 文件中，可以包含多个压缩形式的类文件和子目录，这样既可以节省又可以改善性能。在程序中用到第三方（third-party）的库文件时，通常会给出一个或多个需要包含的 JAR 文件。JDK 也提供了许多的 JAR 文件，例如，在 jre/lib/rt.jar 中包含数千个类库文件。</p><p>3. 提示： JAR 文件使用 ZIP 格式组织文件和子目录。可以使用所有 ZIP 实用程序查看内部的 rt.jar 以及其他的 JAR 文件。</p><p>4. 由于运行时库文件（rt.jar 和在 jre/lib 与 jre/lib/ext 目录下的一些其他的 JAR 文件）会被自动地搜索，所以不必将它们显式地列在类路径中。</p><p>5.javac 编译器总是在当前的目录中查找文件，但 Java 虚拟机仅在类路径中有 “.” 目录的时候才查看当前目录。如果没有设置类路径，那也并不会产生什么问题，默认的类路径包含 “.” 目录。然而如果设置了类路径却忘记了包含 “.” 目录，则程序仍然可以通过编译，但不能运行。</p><p>6. 编译器定位文件要比虚拟机复杂得多。如果引用了一个类，而没有指出这个类所在的包，那么编译器将首先查找包含这个类的包，并询查所有的 import 指令，确定其中是否包含了被引用的类。</p><p>7. 编译器的任务不止这些，它还要查看源文件（Source files）是否比类文件新。如果是这样的话，那么源文件就会被自动地重新编译。在前面已经知道，仅可以导入其他包中的公有类。一个源文件只能包含一个公有类，并且文件名必须与公有类匹配。因此，编译器很容易定位公有类所在的源文件。当然，也可以从当前包中导入非公有类。这些类有可能定义在与类名不同的源文件中。如果从当前包中导入一个类，编译器就要搜索当前包中的所有源文件，以便确定哪个源文件定义了这个类。</p><h3 id="481-设置类路径"><a class="anchor" href="#481-设置类路径">#</a> 4.8.1 设置类路径</h3><p>1. 最好采用 - classpath（或 - cp）选项指定类路径。</p><h2 id="49-文档注释"><a class="anchor" href="#49-文档注释">#</a> 4.9 文档注释</h2><p>1.JDK 包含一个很有用的工具，叫做 javadoc，它可以由源文件生成一个 HTML 文档。</p><h3 id="491-注释的插入"><a class="anchor" href="#491-注释的插入">#</a> 4.9.1 注释的插入</h3><p>1.javadoc 实用程序（utility）从下面几个特性中抽取信息：</p><ul><li>包</li><li>共有类和接口</li><li>公有的和受保护的构造器及方法</li><li>公有的和受保护的域</li></ul><p>2. 如果文档中有到其他文件的链接，例如，图像文件（用户界面的组件的图表或图像等），就应该将这些文件放到子目录 doc-files 中。javadoc 实用程序将从源目录拷贝这些目录及其中的文件到文档目录中。</p><h3 id="492-类注释"><a class="anchor" href="#492-类注释">#</a> 4.9.2 类注释</h3><h3 id="493-方法注释"><a class="anchor" href="#493-方法注释">#</a> 4.9.3 方法注释</h3><ul><li>@param</li><li>@return</li><li>@throws</li></ul><h3 id="494-域注释"><a class="anchor" href="#494-域注释">#</a> 4.9.4 域注释</h3><p>只需要对公有域（通常指的是静态常量）建立文档。</p><h3 id="495-通用注释"><a class="anchor" href="#495-通用注释">#</a> 4.9.5 通用注释</h3><ul><li>@author</li><li>@version</li><li>@since</li><li>@deprecated</li><li>@see</li></ul><h3 id="496-包与概述注释"><a class="anchor" href="#496-包与概述注释">#</a> 4.9.6 包与概述注释</h3><p>要想产生包注释，就需要在每一个包目录中添加一个单独的文件。</p><ul><li>1）提供一个以 package.html 命名的 HTML 文件。在标记 <code>&lt;body&gt;...&lt;/body&gt;</code> 之间的所有文本都会被抽取出来。</li><li>1）2）提供一个以 package-info.java 命名的 Java 文件。这个文件必须包含一个初始的以 <code>/**</code> 和 <code>*/</code> 界定的 Javadoc 注释，跟随在一个包语句之后。它不应该包含更多的代码或注释。</li></ul><h3 id="497-注释的抽取"><a class="anchor" href="#497-注释的抽取">#</a> 4.9.7 注释的抽取</h3><p>javadoc -d docDirectory1 docDirectory2 ...</p><h2 id="410-类设计技巧oop"><a class="anchor" href="#410-类设计技巧oop">#</a> 4.10 类设计技巧（OOP）</h2><ul><li>1. 一定要保证数据私有</li><li>2. 一定要对数据初始化</li><li>3. 不要在类中使用过多的基本类型</li><li>4. 不是所有的域都需要独立的域访问器和域更改器</li><li>5. 将职责过多的类进行分解</li><li>6. 类名和方法名要能够体现他的职责</li><li>7. 优先使用不可变类</li></ul><div class="tags"><a href="/tags/java/" rel="tag"><i class="ic i-tag"></i> java</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2025-12-05 23:27:51" itemprop="dateModified" datetime="2025-12-05T23:27:51+08:00">2025-12-05</time> </span><span id="learn/java/core-java/learn-4/" class="item leancloud_visitors" data-flag-title="原书笔记（卷一 第 4 章）" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/mywechatpay.png" alt="Jalen Chu 微信支付"><p>微信支付</p></div><div><img data-src="/images/myalipay.png" alt="Jalen Chu 支付宝"><p>支付宝</p></div><div><img data-src="/images/mywxgzh.png" alt="Jalen Chu 公众号"><p>公众号</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Jalen Chu <i class="ic i-at"><em>@</em></i>Follow your heart</li><li class="link"><strong>本文链接：</strong> <a href="http://mingcheng.site/learn/java/core-java/learn-4/" title="原书笔记（卷一 第 4 章）">http://mingcheng.site/learn/java/core-java/learn-4/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/learn/java/core-java/learn-1/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;01&#x2F;05&#x2F;agp87xKz4JQUGSO.jpg" title="原书笔记（卷一 1，2，3章）"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Java 核心技术卷 (第 10 版)</span><h3>原书笔记（卷一 1，2，3章）</h3></a></div><div class="item right"><a href="/learn/java/core-java/learn-5/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;01&#x2F;05&#x2F;xuKtdoFjYS4n7iD.jpg" title="原书笔记（卷一 第5章）"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Java 核心技术卷 (第 10 版)</span><h3>原书笔记（卷一 第5章）</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">第 4 章　Java 程序设计概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">4.1 面向对象程序设计概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#411-%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">4.1.1 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#412-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.2.</span> <span class="toc-text">4.1.2 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#413-%E8%AF%86%E5%88%AB%E7%B1%BB"><span class="toc-number">1.1.3.</span> <span class="toc-text">4.1.3 识别类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#414-%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.4.</span> <span class="toc-text">4.1.4 类之间的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E4%BD%BF%E7%94%A8%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">4.2 使用预定义类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#421-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">4.2.1 对象与对象变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#422-java%E7%B1%BB%E5%BA%93%E4%B8%AD%E7%9A%84localdate%E7%B1%BB"><span class="toc-number">1.2.2.</span> <span class="toc-text">4.2.2 Java 类库中的 LocalDate 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#423-%E6%9B%B4%E6%94%B9%E5%99%A8%E6%96%B9%E6%B3%95%E5%92%8C%E8%AE%BF%E9%97%AE%E5%99%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">4.2.3 更改器方法和访问器方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">用户自定义类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#431-employee%E7%B1%BB"><span class="toc-number">1.3.1.</span> <span class="toc-text">4.3.1 Employee 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#432-%E5%A4%9A%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">4.3.2 多个源文件的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#433-%E5%89%96%E6%9E%90employee%E7%B1%BB"><span class="toc-number">1.3.3.</span> <span class="toc-text">4.3.3 剖析 Employee 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#434-%E4%BB%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%80%E5%A7%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">4.3.4 从构造器开始</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#435-%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0%E4%B8%8E%E6%98%BE%E5%BC%8F%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.5.</span> <span class="toc-text">4.3.5 隐式参数与显式参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#436-%E5%B0%81%E8%A3%85%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.3.6.</span> <span class="toc-text">4.3.6 封装的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#437-%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">1.3.7.</span> <span class="toc-text">4.3.7 基于类的访问权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#438-%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.8.</span> <span class="toc-text">4.3.8 私有方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#439-final%E5%AE%9E%E4%BE%8B%E5%9F%9F"><span class="toc-number">1.3.9.</span> <span class="toc-text">4.3.9 final 实例域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E9%9D%99%E6%80%81%E5%9F%9F%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">4.4 静态域和静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#441-%E9%9D%99%E6%80%81%E5%9F%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.4.1 静态域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#442-%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.4.2 静态常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#443-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.4.3 静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#444-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4.4 工厂方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#445-main%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.5.</span> <span class="toc-text">4.4.5 main 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">方法参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0"><span class="toc-number">1.6.</span> <span class="toc-text">对象构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#461-%E9%87%8D%E8%BD%BD"><span class="toc-number">1.6.1.</span> <span class="toc-text">4.6.1 重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#462-%E9%BB%98%E8%AE%A4%E5%9F%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.6.2.</span> <span class="toc-text">4.6.2 默认域初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#463-%E6%97%A0%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.6.3.</span> <span class="toc-text">4.6.3 无参数构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#464-%E6%98%BE%E5%BC%8F%E5%9F%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.6.4.</span> <span class="toc-text">4.6.4 显式域初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#465-%E5%8F%82%E6%95%B0%E5%90%8D"><span class="toc-number">1.6.5.</span> <span class="toc-text">4.6.5 参数名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#466-%E8%B0%83%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.6.6.</span> <span class="toc-text">4.6.6 调用另一个构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#467-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97"><span class="toc-number">1.6.7.</span> <span class="toc-text">4.6.7 初始化块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#468-%E5%AF%B9%E8%B1%A1%E6%9E%90%E6%9E%84%E4%B8%8Efinalize%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.8.</span> <span class="toc-text">4.6.8 对象析构与 finalize 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-%E5%8C%85"><span class="toc-number">1.7.</span> <span class="toc-text">4.7 包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#471-%E7%B1%BB%E7%9A%84%E5%AF%BC%E5%85%A5"><span class="toc-number">1.7.1.</span> <span class="toc-text">4.7.1 类的导入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#472-%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5"><span class="toc-number">1.7.2.</span> <span class="toc-text">4.7.2 静态导入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#473-%E5%B0%86%E7%B1%BB%E6%94%BE%E5%85%A5%E5%8C%85%E4%B8%AD"><span class="toc-number">1.7.3.</span> <span class="toc-text">4.7.3 将类放入包中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#474-%E5%8C%85%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.7.4.</span> <span class="toc-text">4.7.4 包作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%E7%B1%BB%E8%B7%AF%E5%BE%84"><span class="toc-number">1.7.5.</span> <span class="toc-text">4.8 类路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#481-%E8%AE%BE%E7%BD%AE%E7%B1%BB%E8%B7%AF%E5%BE%84"><span class="toc-number">1.7.6.</span> <span class="toc-text">4.8.1 设置类路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="toc-number">1.8.</span> <span class="toc-text">4.9 文档注释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#491-%E6%B3%A8%E9%87%8A%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">1.8.1.</span> <span class="toc-text">4.9.1 注释的插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#492-%E7%B1%BB%E6%B3%A8%E9%87%8A"><span class="toc-number">1.8.2.</span> <span class="toc-text">4.9.2 类注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#493-%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A"><span class="toc-number">1.8.3.</span> <span class="toc-text">4.9.3 方法注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#494-%E5%9F%9F%E6%B3%A8%E9%87%8A"><span class="toc-number">1.8.4.</span> <span class="toc-text">4.9.4 域注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#495-%E9%80%9A%E7%94%A8%E6%B3%A8%E9%87%8A"><span class="toc-number">1.8.5.</span> <span class="toc-text">4.9.5 通用注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#496-%E5%8C%85%E4%B8%8E%E6%A6%82%E8%BF%B0%E6%B3%A8%E9%87%8A"><span class="toc-number">1.8.6.</span> <span class="toc-text">4.9.6 包与概述注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#497-%E6%B3%A8%E9%87%8A%E7%9A%84%E6%8A%BD%E5%8F%96"><span class="toc-number">1.8.7.</span> <span class="toc-text">4.9.7 注释的抽取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#410-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7oop"><span class="toc-number">1.9.</span> <span class="toc-text">4.10 类设计技巧（OOP）</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/learn/java/core-java/learn-1/" rel="bookmark" title="原书笔记（卷一 1，2，3章）">原书笔记（卷一 1，2，3章）</a></li><li class="active"><a href="/learn/java/core-java/learn-4/" rel="bookmark" title="原书笔记（卷一 第4章）">原书笔记（卷一 第4章）</a></li><li><a href="/learn/java/core-java/learn-5/" rel="bookmark" title="原书笔记（卷一 第5章）">原书笔记（卷一 第5章）</a></li><li><a href="/learn/java/core-java/learn-6/" rel="bookmark" title="原书笔记（卷一 第6章）">原书笔记（卷一 第6章）</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Jalen Chu" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Jalen Chu</p><div class="description" itemprop="description">٩(●˙▿˙●)۶…⋆ฺ -></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">700</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">100</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">210</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NpbmNlcmVseVVuaXF1ZQ==" title="https:&#x2F;&#x2F;github.com&#x2F;SincerelyUnique"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9qYWxlbl9jaHU=" title="https:&#x2F;&#x2F;twitter.com&#x2F;jalen_chu"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qYWxlbmNodQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;jalenchu"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvbXkvbS9tdXNpYy9wbGF5bGlzdD9pZD0yMDMxOTczNDY0" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;my&#x2F;m&#x2F;music&#x2F;playlist?id&#x3D;2031973464"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS9KYWxlbkNodQ==" title="https:&#x2F;&#x2F;about.me&#x2F;JalenChu"><i class="ic i-address-card"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjExNTIzNTc0NzlAcXEuY29t" title="mailto:1152357479@qq.com"><i class="ic i-envelope"></i></span> <span class="exturl item facebook" data-url="aHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL2phbGVuLmNodS43OTIv" title="https:&#x2F;&#x2F;www.facebook.com&#x2F;jalen.chu.792&#x2F;"><i class="ic i-facebook"></i></span> <span class="exturl item stackoverflow" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS91c2Vycy8xMTExNzYxOC9qYWxlbi1jaHU=" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;11117618&#x2F;jalen-chu"><i class="ic i-stack-overflow"></i></span> <span class="exturl item youtube" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vY2hhbm5lbC9VQ3FQRnVtUGpGMWVRdVJrdWp0NUR1YWc=" title="https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCqPFumPjF1eQuRkujt5Duag"><i class="ic i-youtube"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li><li class="item"><a href="/webstack/" rel="section"><i class="ic i-user"></i>网址</a></li><li class="item dropdown"><a href="/html/%E5%9C%88%E5%B0%8F%E7%8C%AB.html" rel="section"><i class="ic i-tags"></i>玩耍</a><ul class="submenu"><li class="item"><a href="/html/%E5%9C%88%E5%B0%8F%E7%8C%AB.html" rel="section"><i class="ic i-tags"></i>圈小猫</a></li><li class="item"><a href="/html/%E6%92%95%E6%B8%94%E7%BD%91.html" rel="section"><i class="ic i-tags"></i>撕渔网</a></li><li class="item"><a href="/html/%E5%BD%A9%E8%99%B9%E9%9B%A8.html" rel="section"><i class="ic i-tags"></i>彩虹雨</a></li><li class="item"><a href="/html/%E6%96%B9%E5%9D%97%E7%A9%BF%E6%A2%AD.html" rel="section"><i class="ic i-tags"></i>方块穿梭</a></li><li class="item"><a href="/html/%E7%83%9F%E8%8A%B1%E6%95%88%E6%9E%9C.html" rel="section"><i class="ic i-tags"></i>烟花效果</a></li><li class="item"><a href="/html/%E7%A2%B0%E6%92%9E%E5%B0%8F%E7%90%83.html" rel="section"><i class="ic i-tags"></i>碰撞小球</a></li><li class="item"><a href="/html/%E7%BA%B8%E9%A3%9E%E6%9C%BA.html" rel="section"><i class="ic i-tags"></i>纸飞机</a></li><li class="item"><a href="/html/%E9%AA%87%E5%AE%A2%E5%B8%9D%E5%9B%BD.html" rel="section"><i class="ic i-tags"></i>骇客帝国</a></li><li class="item"><a href="/html/%E7%8E%AB%E7%91%B0%E8%8A%B1.html" rel="section"><i class="ic i-tags"></i>玫瑰花</a></li><li class="item"><a href="/html/%E9%97%AE%E9%97%AE%E9%A2%98.html" rel="section"><i class="ic i-tags"></i>问问题</a></li></ul></li><li class="item"><a href="/html/resume/index.html" rel="section"><i class="ic i-th"></i>简历</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/learn/java/core-java/learn-1/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/learn/java/core-java/learn-5/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/learn/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/algorithm/" title="分类于 算法与面试题">算法与面试题</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/algorithm/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="分类于 面试题">面试题</a></div><span><a href="/learn/algorithm/interview/Python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" title="Python中异常的相关用法">Python中异常的相关用法</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learn/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/devops/" title="分类于 DevOPS">DevOPS</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/devops/Tomcat/" title="分类于 Tomcat">Tomcat</a></div><span><a href="/learn/devops/tomcat/tomcat%E6%9C%8D%E5%8A%A1%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%81%9C%E6%AD%A2/" title="tomcat服务莫名其妙停止">tomcat服务莫名其妙停止</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/learn/algorithm/practise/%E8%AE%A1%E7%AE%97()()()+()()()=()()()/" title="计算()()()+()()()&#x3D;()()()">计算()()()+()()()=()()()</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learn/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/middleware/" title="分类于 中间件学习">中间件学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/middleware/Zookeeper/" title="分类于 Zookeeper">Zookeeper</a></div><span><a href="/learn/middleware/rabbitmq/pika%20Received%20remote%20Channel.Close%20(403)%20%E2%80%9CACCESS_REFUSED/" title="pika Received remote Channel.Close (403) ACCESS_REFUSED">pika Received remote Channel.Close (403) ACCESS_REFUSED</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learn/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/Python-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" title="分类于 Python 语言学习">Python 语言学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/python/Pandas/" title="分类于 Pandas">Pandas</a></div><span><a href="/learn/python/pandas/pandas%E6%89%BE%E5%87%BA%E6%AF%94%E8%BE%83%E4%B8%A4%E5%88%97%E5%B9%B6%E6%89%BE%E5%87%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%80%BC/" title="pandas找出比较两列并找出不同的值">pandas找出比较两列并找出不同的值</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learn/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/devops/" title="分类于 DevOPS">DevOPS</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/devops/%E5%85%84%E5%BC%9F%E8%BF%9ELinux%E5%AD%A6%E4%B9%A0/" title="分类于 兄弟连 Linux 学习">兄弟连 Linux 学习</a></div><span><a href="/learn/devops/linux-basic/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86%EF%BC%88%E5%85%84%E5%BC%9F%E8%BF%9E%EF%BC%89/" title="日志管理（兄弟连）">日志管理（兄弟连）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learn/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/frontent/" title="分类于 前端知识学习">前端知识学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/frontent/AngularJS/" title="分类于 AngularJS">AngularJS</a></div><span><a href="/learn/frontent/angular-js/Angular%E5%AD%A6%E4%B9%A0%EF%BC%8813%EF%BC%89%E4%B9%8Bget%20post%20jsonp%20axios%E8%AF%B7%E6%B1%82/" title="Angular学习（13）之get post jsonp axios请求">Angular学习（13）之get post jsonp axios请求</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/life/" title="分类于 生活">生活</a> <i class="ic i-angle-right"></i> <a href="/categories/life/%E5%B0%8F%E8%A7%86%E9%A2%91/" title="分类于 小视频">小视频</a></div><span><a href="/life/video/%E7%94%B0%E5%9F%82%E4%B8%8A%E7%9A%84%E6%A2%A6/" title="田埂上的梦">田埂上的梦</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learn/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/principle/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/principle/HeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 HeadFirst 设计模式">HeadFirst 设计模式</a></div><span><a href="/learn/principle/head-first-design-pattern/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/" title="命令模式">命令模式</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/java.lang.IllegalStateException%20Neither%20BindingResult%20nor%20plain%20target%20object%20for%20bean%20name%20'user'/" title="java.lang.IllegalStateException Neither BindingResult nor plain target object for bean name &#39;user&#39;">java.lang.IllegalStateException Neither BindingResult nor plain target object for bean name 'user'</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Jalen Chu @ Jalen's Blog</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">2m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">29:45</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"learn/java/core-java/learn-4/",favicon:{show:"（●´3｀●）復活成功",hide:"(´Д｀)瀏覽器崩潰啦"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:{placeholder:"1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪"},fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?908585f2e8b845b564946752e587f4a0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/z16.model.json"},display:{position:"left",width:200,height:400},mobile:{show:!0},react:{opacity:.7}})</script></body></html>