<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="MlAWwzcGEsG8nn2V34gojElRFcnHeEgBvIS8Ek1LQ0c"><meta name="msvalidate.01" content="8BDA269F1F25AB9AB2160E377B2334C5"><link rel="alternate" type="application/rss+xml" title="Follow your heart" href="http://jalen.site/rss.xml"><link rel="alternate" type="application/atom+xml" title="Follow your heart" href="http://jalen.site/atom.xml"><link rel="alternate" type="application/json" title="Follow your heart" href="http://jalen.site/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="java"><link rel="canonical" href="http://jalen.site/learn/java/core-java/learn-6/"><title>原书笔记（卷一 第 6 章） - Java 核心技术卷 (第 10 版) - Java 语言学习 - 学习 | Jalen's Blog = Follow your heart = A happy life</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">原书笔记（卷一 第 6 章）</h1><div class="meta"><span class="item" title="创建时间：2021-07-26 13:33:35"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-07-26T13:33:35+08:00">2021-07-26</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>12k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>10 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jalen's Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2023/01/05/RFdhPomTYO1Cjp4.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/01/05/291AVv5PxJZyUw3.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/01/05/vVrSIixC8fEj4Jd.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/01/05/6aZYmqOpinP8eFN.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/01/05/TODBy9PpixvXf4K.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/01/05/i6VqYjfsF7IzlWU.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/learn/" itemprop="item" rel="index" title="分类于 学习"><span itemprop="name">学习</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/learn/Java-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" itemprop="item" rel="index" title="分类于 Java 语言学习"><span itemprop="name">Java 语言学习</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/learn/java/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7-%E7%AC%AC10%E7%89%88/" itemprop="item" rel="index" title="分类于 Java 核心技术卷 (第 10 版)"><span itemprop="name">Java 核心技术卷 (第 10 版)</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://jalen.site/learn/java/core-java/learn-6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Jalen Chu"><meta itemprop="description" content="A happy life, ٩(●˙▿˙●)۶…⋆ฺ ->"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Follow your heart"></span><div class="body md" itemprop="articleBody"><h1 id="第6章-接口-lambda表达式与内部类"><a class="anchor" href="#第6章-接口-lambda表达式与内部类">#</a> 第 6 章 接口、lambda 表达式与内部类</h1><blockquote><p>接口 - 主要用来描述类具有什么功能，而并不给出每个功能的具体实现。</p><p>内部类</p><p>接口示例</p><p>代理</p><p>lambda 表达式</p></blockquote><h2 id="61-接口"><a class="anchor" href="#61-接口">#</a> 6.1 接口</h2><h3 id="611-接口概念"><a class="anchor" href="#611-接口概念">#</a> 6.1.1 接口概念</h3><p>1. 接口不是类，而是对类的一组需求描述。</p><p>2.“如果类遵从某个特定接口，那么就履行这项服务”。</p><p>3. 接口中的所有方法自动地属于 public。因此，在接口中声明方法时，不必提供关键字 public。</p><p>4. 接口绝对不能含有实例域。</p><p>5. 如果希望使用 Arrays 类的 sort 方法对 Employee 对象数组进行排序，Employee 类就必须实现 Comparable 接口。</p><p>6.compareTo (): 在调用 x.compareTo（y）的时候，这个 compareTo 方法必须确实比较两个对象的内容，并返回比较的结果。当 x 小于 y 时，返回一个负数；当 x 等于 y 时，返回 0；否则返回一个正数。</p><p>7. 为了让类实现一个接口，通常需要下面两个步骤:</p><ul><li>1）将类声明为实现给定的接口。使用关键字 implements。</li><li>2）对接口中的所有方法进行定义。</li></ul><p>8. 在接口声明中，没有将 compareTo 方法声明为 public，这是因为在接口中的所有方法都自动地是 public。不过，在实现接口时，必须把方法声明为 public；否则，编译器将认为这个方法的访问属性是包可见性，即类的默认访问属性，之后编译器就会给出试图提供更严格的访问权限的警告信息。</p><p>9. 不符合 “反对称” 的规则。如果 x 是一个 Employee 对象，y 是一个 Manager 对象，调用 x.compareTo（y）不会抛出异常，它只是将 x 和 y 都作为雇员进行比较。但是反过来，y.compareTo（x）将会抛出一个 ClassCastException。</p><h3 id="612-接口的特性"><a class="anchor" href="#612-接口的特性">#</a> 6.1.2 接口的特性</h3><p>1. 不能使用 new 实例化一个接口，即不能构造接口的对象，但是能声明接口的变量。</p><p>2. 可以以接口为基础扩展一个接口。</p><p>3. 虽然在接口中不能包含实例域或静态方法，但却可以包含常量。与接口中的方法都自动地被设置为 public 一样，接口中的域将被自动设为 public static final。</p><p>4. 接口可以只定义常量，如 SwingConstants 接口。不过这样使用有些偏离接口的初衷。</p><p>5.Cloneable 接口。</p><h3 id="613-接口与抽象类"><a class="anchor" href="#613-接口与抽象类">#</a> 6.1.3 接口与抽象类</h3><p>1. 使用抽象类表示通用属性存在这样一个问题：每个类只能扩展于一个类。假设 Employee 类已经扩展于一个类，例如 Person，它就不能再像下面这样扩展第二个类了。</p><p>2. 有些程序设计语言允许一个类有多个超类，例如 C++。我们将此特性称为多重继承（multiple inheritance）。而 Java 的设计者选择了不支持多继承，其主要原因是多继承会让语言本身变得非常复杂（如同 C++），效率也会降低（如同 Eiffel）。实际上，接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。</p><h3 id="614-静态方法"><a class="anchor" href="#614-静态方法">#</a> 6.1.4 静态方法</h3><p>在 Java SE 8 中，允许在接口中增加静态方法。理论上讲，没有任何理由认为这是不合法的。只是这有违于将接口作为抽象规范的初衷。</p><h3 id="615-默认方法"><a class="anchor" href="#615-默认方法">#</a> 6.1.5 默认方法</h3><p>1. 可以为接口方法提供一个默认实现。必须用 default 修饰符标记这样一个方法。</p><p>2. 在 Java SE 8 中，可以把所有方法声明为默认方法，这些默认方法什么也不做。</p><p>3. 在 Java API 中，你会看到很多接口都有相应的伴随类，这个伴随类中实现了相应接口的部分或所有方法，如 Collection/AbstractCollection 或 MouseListener/MouseAdapter。在 Java SE 8 中，这个技术已经过时。现在可以直接在接口中实现方法。</p><h3 id="616-解决默认方法冲突"><a class="anchor" href="#616-解决默认方法冲突">#</a> 6.1.6 解决默认方法冲突</h3><p>1. 如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生什么情况？（类优先规则）</p><ul><li>1）超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。</li><li>2）接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须覆盖这个方法来解决冲突。</li></ul><p>2.“类优先” 规则可以确保与 Java SE 7 的兼容性。如果为一个接口增加默认方法，这对于有这个默认方法之前能正常工作的代码不会有任何影响。</p><p>3. 千万不要让一个默认方法重新定义 Object 类中的某个方法。例如，不能为 toString 或 equals 定义默认方法，尽管对于 List 之类的接口这可能很有吸引力。由于 “类优先” 规则，这样的方法绝对无法超越 Object.toString 或 Objects.equals。</p><h2 id="62-接口示例"><a class="anchor" href="#62-接口示例">#</a> 6.2 接口示例</h2><h3 id="621-接口与回调"><a class="anchor" href="#621-接口与回调">#</a> 6.2.1 接口与回调</h3><p>回调（callback）是一种常见的程序设计模式。在这种模式中，可以指出某个特定事件发生时应该采取的动作。例如，可以指出在按下鼠标或选择某个菜单项时应该采取什么行动。</p><h3 id="622-comparator接口"><a class="anchor" href="#622-comparator接口">#</a> 6.2.2 Comparator 接口</h3><h3 id="623-对象克隆"><a class="anchor" href="#623-对象克隆">#</a> 6.2.3 对象克隆</h3><p>1. 对象克隆没有这么简单。clone 方法是 Object 的一个 protected 方法，这说明你的代码不能直接调用这个方法。只有 Employee 类可以克隆 Employee 对象。这个限制是有原因的。想想看 Object 类如何实现 clone。它对于这个对象一无所知，所以只能逐个域地进行拷贝。如果对象中的所有数据域都是数值或其他基本类型，拷贝这些域没有任何问题。但是如果对象包含子对象的引用，拷贝域就会得到相同子对象的另一个引用，这样一来，原对象和克隆的对象仍然会共享一些信息。</p><p>2. 默认的克隆操作是 “浅拷贝”，并没有克隆对象中引用的其他对象。使用时可能带来安全问题。</p><p>3. 浅拷贝安全性：如果原对象和浅克隆对象共享的子对象是不可变的，那么这种共享就是安全的。如果子对象属于一个不可变的类，如 String，就是这种情况。或者在对象的生命期中，子对象一直包含不变的常量，没有更改器方法会改变它，也没有方法会生成它的引用，这种情况下同样是安全的。</p><p>4. 在这里，Cloneable 接口的出现与接口的正常使用并没有关系。具体来说，它没有指定 clone 方法，这个方法是从 Object 类继承的。这个接口只是作为一个标记，指示类设计者了解克隆过程。对象对于克隆很 “偏执”，如果一个对象请求克隆，但没有实现这个接口，就会生成一个受查异常。</p><p>5.Cloneable 接口是 Java 提供的一组标记接口（tagging interface）之一。不包含任何方法。它唯一的作用就是允许在类型查询中使用 instanceof。建议在自己的程序中不要使用标记接口。</p><p>6. 建立深拷贝，还需要做更多工作，即克隆对象中可变的实例域。</p><p>7. 克隆没有你想象中那么常用。标准库中只有不到 5% 的类实现了 clone。</p><p>8. 所有数组类型都有一个 public 的 clone 方法，而不是 protected。可以用这个方法建立一个新数组，包含原数组所有元素的副本。</p><h2 id="63-lambda表达式"><a class="anchor" href="#63-lambda表达式">#</a> 6.3 lambda 表达式</h2><h3 id="631-为什么引入lambda表达式"><a class="anchor" href="#631-为什么引入lambda表达式">#</a> 6.3.1 为什么引入 lambda 表达式</h3><p>lambda 表达式是一个可传递的代码块，可以在以后执行一次或多次。</p><h3 id="632-lambda表达式的语法"><a class="anchor" href="#632-lambda表达式的语法">#</a> 6.3.2 lambda 表达式的语法</h3><h3 id="633-函数式接口"><a class="anchor" href="#633-函数式接口">#</a> 6.3.3 函数式接口</h3><p>1. 对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个 lambda 表达式。这种接口称为函数式接口（functional interface）。</p><p>2. 实际上，在 Java 中，对 lambda 表达式所能做的也只是能转换为函数式接口。在其他支持函数字面量的程序设计语言中，可以声明函数类型（如（String，String）-&gt;int）、声明这些类型的变量，还可以使用变量保存函数表达式。不过，Java 设计者还是决定保持我们熟悉的接口概念，没有为 Java 语言增加函数类型。</p><p>3. <code>Predicate&lt;T&gt;</code> 接口。</p><h3 id="634-方法引用"><a class="anchor" href="#634-方法引用">#</a> 6.3.4 方法引用</h3><p>1. 用：：操作符分隔方法名与对象或类名。主要有 3 种情况：</p><ul><li>object：：instanceMethod</li><li>Class：：staticMethod</li><li>Class：：instanceMethod</li></ul><p>2. 在前 2 种情况中，方法引用等价于提供方法参数的 lambda 表达式。即 System.out：：println 等价于 x-&gt;System.out.println（x）。类似地，Math：：pow 等价于（x，y）-&gt;Math.pow（x，y）。对于第 3 种情况，第 1 个参数会成为方法的目标。例如，String：：compareToIgnoreCase 等同于（x，y）-&gt;x.compareToIgnoreCase（y）。</p><p>3. 如果有多个同名的重载方法，编译器就会尝试从上下文中找出你指的那一个方法。例如，Math.max 方法有两个版本，一个用于整数，另一个用于 double 值。选择哪一个版本取决于 Math：：max 转换为哪个函数式接口的方法参数。类似于 lambda 表达式，方法引用不能独立存在，总是会转换为函数式接口的实例。</p><h3 id="635-构造器引用"><a class="anchor" href="#635-构造器引用">#</a> 6.3.5 构造器引用</h3><p>构造器引用与方法引用很类似，只不过方法名为 new。例如，Person：：new 是 Person 构造器的一个引用。哪一个构造器呢？这取决于上下文。</p><h3 id="636-变量作用域"><a class="anchor" href="#636-变量作用域">#</a> 6.3.6 变量作用域</h3><p>1.lambda 表达式有 3 个部分：</p><ul><li>1）一个代码块；</li><li>2）参数；</li><li>3）自由变量的值，这是指非参数而且不在代码中定义的变量。</li></ul><p>2. 关于代码块以及自由变量值有一个术语：闭包（closure）。在 Java 中，lambda 表达式就是闭包。</p><p>3. 这里有一条规则：lambda 表达式中捕获的变量必须实际上是最终变量（effectively final）。实际上的最终变量是指，这个变量初始化之后就不会再为它赋新值。</p><p>4.lambda 表达式的体与嵌套块有相同的作用域。这里同样适用命名冲突和遮蔽的有关规则。在 lambda 表达式中声明与一个局部变量同名的参数或局部变量是不合法的。</p><h3 id="637-处理lambda表达式"><a class="anchor" href="#637-处理lambda表达式">#</a> 6.3.7 处理 lambda 表达式</h3><p>1. 使用 lambda 表达式的重点是延迟执行（deferred execution）。毕竟，如果想要立即执行代码，完全可以直接执行，而无需把它包装在一个 lambda 表达式中。之所以希望以后再执行代码，这有很多原因，如：</p><ul><li>在一个单独的线程中运行代码；</li><li>多次运行代码；</li><li>在算法的适当位置运行代码（例如，排序中的比较操作）；</li><li>发生某种情况时执行代码（如，点击了一个按钮，数据到达，等等）；</li><li>只在必要时才运行代码。</li></ul><p>2. 常用函数式接口</p><table><thead><tr><th>Interface</th><th>Description</th></tr></thead><tbody><tr><td><code>BiConsumer&lt;T,U&gt;</code></td><td>It represents an operation that accepts two input arguments and returns no result.</td></tr><tr><td><code>Consumer&lt;T&gt;</code></td><td>It represents an operation that accepts a single argument and returns no result.</td></tr><tr><td><code>Function&lt;T,R&gt;</code></td><td>It represents a function that accepts one argument and returns a result.</td></tr><tr><td><code>Predicate&lt;T&gt;</code></td><td>It represents a predicate (boolean-valued function) of one argument.</td></tr><tr><td><code>BiFunction&lt;T,U,R&gt;</code></td><td>It represents a function that accepts two arguments and returns a a result.</td></tr><tr><td><code>BinaryOperator&lt;T&gt;</code></td><td>It represents an operation upon two operands of the same data type. It returns a result of the same type as the operands.</td></tr><tr><td><code>BiPredicate&lt;T,U&gt;</code></td><td>It represents a predicate (boolean-valued function) of two arguments.</td></tr><tr><td><code>BooleanSupplier</code></td><td>It represents a supplier of boolean-valued results.</td></tr><tr><td><code>DoubleBinaryOperator</code></td><td>It represents an operation upon two double type operands and returns a double type value.</td></tr><tr><td><code>DoubleConsumer</code></td><td>It represents an operation that accepts a single double type argument and returns no result.</td></tr><tr><td><code>DoubleFunction&lt;R&gt;</code></td><td>It represents a function that accepts a double type argument and produces a result.</td></tr><tr><td><code>DoublePredicate</code></td><td>It represents a predicate (boolean-valued function) of one double type argument.</td></tr><tr><td><code>DoubleSupplier</code></td><td>It represents a supplier of double type results.</td></tr><tr><td><code>DoubleToIntFunction</code></td><td>It represents a function that accepts a double type argument and produces an int type result.</td></tr><tr><td><code>DoubleToLongFunction</code></td><td>It represents a function that accepts a double type argument and produces a long type result.</td></tr><tr><td><code>DoubleUnaryOperator</code></td><td>It represents an operation on a single double type operand that produces a double type result.</td></tr><tr><td><code>IntBinaryOperator</code></td><td>It represents an operation upon two int type operands and returns an int type result.</td></tr><tr><td><code>IntConsumer</code></td><td>It represents an operation that accepts a single integer argument and returns no result.</td></tr><tr><td><code>IntFunction&lt;R&gt;</code></td><td>It represents a function that accepts an integer argument and returns a result.</td></tr><tr><td><code>IntPredicate</code></td><td>It represents a predicate (boolean-valued function) of one integer argument.</td></tr><tr><td><code>IntSupplier</code></td><td>It represents a supplier of integer type.</td></tr><tr><td><code>IntToDoubleFunction</code></td><td>It represents a function that accepts an integer argument and returns a double.</td></tr><tr><td><code>IntToLongFunction</code></td><td>It represents a function that accepts an integer argument and returns a long.</td></tr><tr><td><code>IntUnaryOperator</code></td><td>It represents an operation on a single integer operand that produces an integer result.</td></tr><tr><td><code>LongBinaryOperator</code></td><td>It represents an operation upon two long type operands and returns a long type result.</td></tr><tr><td><code>LongConsumer</code></td><td>It represents an operation that accepts a single long type argument and returns no result.</td></tr><tr><td><code>LongFunction&lt;R&gt;</code></td><td>It represents a function that accepts a long type argument and returns a result.</td></tr><tr><td><code>LongPredicate</code></td><td>It represents a predicate (boolean-valued function) of one long type argument.</td></tr><tr><td><code>LongSupplier</code></td><td>It represents a supplier of long type results.</td></tr><tr><td><code>LongToDoubleFunction</code></td><td>It represents a function that accepts a long type argument and returns a result of double type.</td></tr><tr><td><code>LongToIntFunction</code></td><td>It represents a function that accepts a long type argument and returns an integer result.</td></tr><tr><td><code>LongUnaryOperator</code></td><td>It represents an operation on a single long type operand that returns a long type result.</td></tr><tr><td><code>ObjDoubleConsumer&lt;T&gt;</code></td><td>It represents an operation that accepts an object and a double argument, and returns no result.</td></tr><tr><td><code>ObjIntConsumer&lt;T&gt;</code></td><td>It represents an operation that accepts an object and an integer argument. It does not return result.</td></tr><tr><td><code>ObjLongConsumer&lt;T&gt;</code></td><td>It represents an operation that accepts an object and a long argument, it returns no result.</td></tr><tr><td><code>Supplier&lt;T&gt;</code></td><td>It represents a supplier of results.</td></tr><tr><td><code>ToDoubleBiFunction&lt;T,U&gt;</code></td><td>It represents a function that accepts two arguments and produces a double type result.</td></tr><tr><td><code>ToDoubleFunction&lt;T&gt;</code></td><td>It represents a function that returns a double type result.</td></tr><tr><td><code>ToIntBiFunction&lt;T,U&gt;</code></td><td>It represents a function that accepts two arguments and returns an integer.</td></tr><tr><td><code>ToIntFunction&lt;T&gt;</code></td><td>It represents a function that returns an integer.</td></tr><tr><td><code>ToLongBiFunction&lt;T,U&gt;</code></td><td>It represents a function that accepts two arguments and returns a result of long type.</td></tr><tr><td><code>ToLongFunction&lt;T&gt;</code></td><td>It represents a function that returns a result of long type.</td></tr><tr><td><code>UnaryOperator&lt;T&gt;</code></td><td>It represents an operation on a single operand that returnsa a result of the same type as its operand.</td></tr></tbody></table><p>3. 如果设计你自己的接口，其中只有一个抽象方法，可以用 @FunctionalInterface 注解来标记这个接口。这样做有两个优点。如果你无意中增加了另一个非抽象方法，编译器会产生一个错误消息。另外 javadoc 页里会指出你的接口是一个函数式接口。并不是必须使用注解。根据定义，任何有一个抽象方法的接口都是函数式接口。不过使用 @FunctionalInterface 注解确实是一个很好的做法。</p><h3 id="638-再谈comprator"><a class="anchor" href="#638-再谈comprator">#</a> 6.3.8 再谈 Comprator</h3><p>1.Comparator 接口包含很多方便的静态方法来创建比较器。这些方法可以用于 lambda 表达式或方法引用。</p><p>2. 如果键函数可以返回 null，可能就要用到 nullsFirst 和 nullsLast 适配器。这些静态方法会修改现有的比较器，从而在遇到 null 值时不会抛出异常，而是将这个值标记为小于或大于正常值。</p><h2 id="64-内部类"><a class="anchor" href="#64-内部类">#</a> 6.4 内部类</h2><p>1. 内部类（inner class）是定义在另一个类中的类。为什么需要使用内部类呢？其主要原因有以下三点：</p><ul><li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。</li><li>内部类可以对同一个包中的其他类隐藏起来。</li><li>当想要定义一个回调函数且不想编写大量代码时，使用匿名（anonymous）内部类比较便捷。</li></ul><p>2. 嵌套类有两个好处：命名控制和访问控制。由于名字 Iterator 嵌套在 LinkedList 类的内部，所以在外部被命名为 LinkedList：：Iterator，这样就不会与其他名为 Iterator 的类发生冲突。在 Java 中这个并不重要，因为 Java 包已经提供了相同的命名控制。需要注意的是，Link 类位于 LinkedList 类的私有部分，因此，Link 对其他的代码均不可见。鉴于此情况，可以将 Link 的数据域设计为公有的，它仍然是安全的。这些数据域只能被 LinkedList 类（具有访问这些数据域的合理需要）中的方法访问，而不会暴露给其他的代码。在 Java 中，只有内部类能够实现这样的控制。</p><p>3.Java 内部类还有另外一个功能，内部类的对象有一个隐式引用，它引用了实例化该内部对象的外围类对象。通过这个指针，可以访问外围类对象的全部状态。static 内部类没有这种附加指针。</p><h3 id="641-使用内部类访问对象状态"><a class="anchor" href="#641-使用内部类访问对象状态">#</a> 6.4.1 使用内部类访问对象状态</h3><p>1. 从传统意义上讲，一个方法可以引用调用这个方法的对象数据域。内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。内部类的对象总有一个隐式引用，它指向了创建它的外部类对象。这个引用在内部类的定义中是不可见的。</p><p>2. 外围类的引用在构造器中设置。编译器修改了所有的内部类的构造器，添加一个外围类引用的参数。</p><p>3. 访问控制。如果有一个类是一个常规类，它可能就需要通过提供一个公有方法给外部类访问它的实例域，而使用内部类可以给予改进，即不必提供仅用于访问其他类的访问器（公有 public 访问）。</p><p>4. 只有内部类可以是私有类，而常规类只可以具有包可见性，或公有可见性。</p><h3 id="642-内部类的特殊语法规则"><a class="anchor" href="#642-内部类的特殊语法规则">#</a> 6.4.2 内部类的特殊语法规则</h3><p>1. 内部类中声明的所有静态域都必须是 final。原因很简单。我们希望一个静态域只有一个实例，不过对于每个外部对象，会分别有一个单独的内部类实例。如果这个域不是 final，它可能就不是唯一的。</p><p>2. 内部类不能有 static 方法。Java 语言规范对这个限制没有做任何解释。也可以允许有静态方法，但只能访问外围类的静态域和方法。显然，Java 设计者认为相对于这种复杂性来说，它带来的好处有些得不偿失。</p><h3 id="643-内部类是否有用-必要和安全"><a class="anchor" href="#643-内部类是否有用-必要和安全">#</a> 6.4.3 内部类是否有用、必要和安全</h3><p>1. 内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用 $（美元符号）分隔外部类名与内部类名的常规类文件，而虚拟机则对此一无所知。</p><p>2. 当在 Java 1.1 的 Java 语言中增加内部类时，很多程序员都认为这是一项很主要的新特性，但这却违背了 Java 要比 C++ 更加简单的设计理念。内部类的语法很复杂（匿名内部类更加复杂）。它与访问控制和安全性等其他的语言特性的没有明显的关联。由于增加了一些看似优美有趣，实属没必要的特性，似乎 Java 也开始走上了许多语言饱受折磨的毁灭性道路上。</p><p>3. 由于内部类拥有访问特权，所以与常规类比较起来功能更加强大。如果内部类访问了私有数据域，就有可能通过附加在外围类所在包中的其他类访问它们，但做这些事情需要高超的技巧和极大的决心。比如熟悉类文件结构的黑客可以使用十六进制编辑器轻松地创建一个用虚拟机指令调用那个方法的类文件。由于隐秘地访问方法需要拥有包可见性，所以攻击代码需要与被攻击类放在同一个包中。</p><h3 id="644-局部内部类"><a class="anchor" href="#644-局部内部类">#</a> 6.4.4 局部内部类</h3><p>1. 可以在一个方法中定义局部类。</p><p>2. 局部类不能用 public 或 private 访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。</p><p>3. 局部类有一个优势，即对外部世界可以完全地隐藏起来。</p><h3 id="645-由外部方法访问变量"><a class="anchor" href="#645-由外部方法访问变量">#</a> 6.4.5 由外部方法访问变量</h3><p>1. 与其他内部类相比较，局部类还有一个优点。它们不仅能够访问包含它们的外部类，还可以访问局部变量。不过，那些局部变量必须事实上为 final。这说明，它们一旦赋值就绝不会改变。</p><p>2. 从程序员的角度看，局部变量的访问非常容易。它减少了需要显式编写的实例域，从而使得内部类更加简单。</p><p>3. 在内部类被首次提出时，原型编译器对内部类中修改的局部变量自动地进行转换。不过，后来这种做法被废弃。毕竟，这里存在一个危险。同时在多个线程中执行内部类中的代码时，这种并发更新会导致竞态条件。</p><h3 id="646-匿名内部类"><a class="anchor" href="#646-匿名内部类">#</a> 6.4.6 匿名内部类</h3><p>1. 将局部内部类的使用再深入一步。假如只创建这个类的一个对象，就不必命名了。这种类被称为匿名内部类（anonymous inner class）。</p><p>2. 由于构造器的名字必须与类名相同，而匿名类没有类名，所以，匿名类不能有构造器。取而代之的是，将构造器参数传递给超类（superclass）构造器。尤其是在内部类实现接口的时候，不能有任何构造参数。不仅如此，还要提供一组括号。</p><p>3. 使用匿名内部类的解决方案比较简短、更切实际、更易于理解。</p><p>4. 多年来，Java 程序员习惯的做法是用匿名内部类实现事件监听器和其他回调。如今最好还是使用 lambda 表达式。</p><h3 id="647-静态内部类"><a class="anchor" href="#647-静态内部类">#</a> 6.4.7 静态内部类</h3><p>1. 有时候，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象。为此，可以将内部类声明为 static，以便取消产生的引用。</p><p>2. 只有内部类可以声明为 static。静态内部类的对象除了没有对生成它的外围类对象的引用特权外，与其他所有内部类完全一样。</p><p>3. 在内部类不需要访问外围类对象的时候，应该使用静态内部类。</p><p>4. 与常规内部类不同，静态内部类可以有静态域和方法。</p><p>5. 声明在接口中的内部类自动成为 static 和 public 类。</p><h2 id="65-代理"><a class="anchor" href="#65-代理">#</a> 6.5 代理</h2><p>利用代理可以在运行时创建一个实现了一组给定接口的新类。这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用。对于应用程序设计人员来说，遇到这种情况的机会很少。然而，对于系统程序设计人员来说，代理带来的灵活性却十分重要。</p><h3 id="651-何时使用代理"><a class="anchor" href="#651-何时使用代理">#</a> 6.5.1 何时使用代理</h3><p>1. 假设有一个表示接口的 Class 对象（有可能只包含一个接口），它的确切类型在编译时无法知道。这确实有些难度。要想构造一个实现这些接口的类，就需要使用 newInstance 方法或反射找出这个类的构造器。但是，不能实例化一个接口，需要在程序处于运行状态时定义一个新类。 为了解决这个问题，有些程序将会生成代码；将这些代码放置在一个文件中；调用编译器；然后再加载结果类文件。很自然，这样做的速度会比较慢，并且需要将编译器与程序放在一起。而代理机制则是一种更好的解决方案。代理类可以在运行时创建全新的类。这样的代理类能够实现指定的接口。尤其是，它具有下列方法：</p><ul><li>指定接口所需要的全部方法。</li><li>Object 类中的全部方法，例如，toString、equals 等。</li></ul><p>2. 然而，不能在运行时定义这些方法的新代码。而是要提供一个调用处理器（invocation handler）。调用处理器是实现了 InvocationHandler 接口的类对象。在这个接口中只有一个方法 invoke (Object proxy, Method method, Object [] args), 无论何时调用代理对象的方法，调用处理器的 invoke 方法都会被调用，并向其传递 Method 对象和原始的调用参数。调用处理器必须给出处理调用的方式。</p><h3 id="652-创建代理对象"><a class="anchor" href="#652-创建代理对象">#</a> 6.5.2 创建代理对象</h3><p>1. 要想创建一个代理对象，需要使用 Proxy 类的 newProxyInstance 方法。这个方法有三个参数：</p><ul><li>一个类加载器（class loader）。作为 Java 安全模型的一部分，对于系统类和从因特网上下载下来的类，可以使用不同的类加载器。目前，用 null 表示使用默认的类加载器。</li><li>一个 Class 对象数组，每个元素都是需要实现的接口。</li><li>一个调用处理器。</li></ul><div class="tags"><a href="/tags/java/" rel="tag"><i class="ic i-tag"></i> java</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-08-07 01:04:04" itemprop="dateModified" datetime="2024-08-07T01:04:04+08:00">2024-08-07</time> </span><span id="learn/java/core-java/learn-6/" class="item leancloud_visitors" data-flag-title="原书笔记（卷一 第 6 章）" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/mywechatpay.png" alt="Jalen Chu 微信支付"><p>微信支付</p></div><div><img data-src="/images/myalipay.png" alt="Jalen Chu 支付宝"><p>支付宝</p></div><div><img data-src="/images/mywxgzh.png" alt="Jalen Chu 公众号"><p>公众号</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Jalen Chu <i class="ic i-at"><em>@</em></i>Follow your heart</li><li class="link"><strong>本文链接：</strong> <a href="http://jalen.site/learn/java/core-java/learn-6/" title="原书笔记（卷一 第 6 章）">http://jalen.site/learn/java/core-java/learn-6/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/learn/java/core-java/learn-5/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;01&#x2F;05&#x2F;oqOkxL15fMtCJed.jpg" title="原书笔记（卷一 第5章）"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Java 核心技术卷 (第 10 版)</span><h3>原书笔记（卷一 第5章）</h3></a></div><div class="item right"><a href="/learn/devops/docker/centos-docker%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;01&#x2F;05&#x2F;eaTIyAMYK9Skz8c.jpg" title="centos docker简单操作"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Docker</span><h3>centos docker简单操作</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E6%8E%A5%E5%8F%A3-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">第 6 章 接口、lambda 表达式与内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.</span> <span class="toc-text">6.1 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#611-%E6%8E%A5%E5%8F%A3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">6.1.1 接口概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#612-%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.2.</span> <span class="toc-text">6.1.2 接口的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#613-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.1.3.</span> <span class="toc-text">6.1.3 接口与抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#614-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.4.</span> <span class="toc-text">6.1.4 静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#615-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.5.</span> <span class="toc-text">6.1.5 默认方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#616-%E8%A7%A3%E5%86%B3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%86%B2%E7%AA%81"><span class="toc-number">1.1.6.</span> <span class="toc-text">6.1.6 解决默认方法冲突</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E6%8E%A5%E5%8F%A3%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.</span> <span class="toc-text">6.2 接口示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#621-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%9B%9E%E8%B0%83"><span class="toc-number">1.2.1.</span> <span class="toc-text">6.2.1 接口与回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#622-comparator%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.2.</span> <span class="toc-text">6.2.2 Comparator 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#623-%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86"><span class="toc-number">1.2.3.</span> <span class="toc-text">6.2.3 对象克隆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">6.3 lambda 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#631-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">6.3.1 为什么引入 lambda 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#632-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">6.3.2 lambda 表达式的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#633-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.3.</span> <span class="toc-text">6.3.3 函数式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#634-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.4.</span> <span class="toc-text">6.3.4 方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#635-%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.5.</span> <span class="toc-text">6.3.5 构造器引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#636-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.3.6.</span> <span class="toc-text">6.3.6 变量作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#637-%E5%A4%84%E7%90%86lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.7.</span> <span class="toc-text">6.3.7 处理 lambda 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#638-%E5%86%8D%E8%B0%88comprator"><span class="toc-number">1.3.8.</span> <span class="toc-text">6.3.8 再谈 Comprator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">6.4 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#641-%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81"><span class="toc-number">1.4.1.</span> <span class="toc-text">6.4.1 使用内部类访问对象状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#642-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%89%B9%E6%AE%8A%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">1.4.2.</span> <span class="toc-text">6.4.2 内部类的特殊语法规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#643-%E5%86%85%E9%83%A8%E7%B1%BB%E6%98%AF%E5%90%A6%E6%9C%89%E7%94%A8-%E5%BF%85%E8%A6%81%E5%92%8C%E5%AE%89%E5%85%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">6.4.3 内部类是否有用、必要和安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#644-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.4.4.</span> <span class="toc-text">6.4.4 局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#645-%E7%94%B1%E5%A4%96%E9%83%A8%E6%96%B9%E6%B3%95%E8%AE%BF%E9%97%AE%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.5.</span> <span class="toc-text">6.4.5 由外部方法访问变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#646-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.4.6.</span> <span class="toc-text">6.4.6 匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#647-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.4.7.</span> <span class="toc-text">6.4.7 静态内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-%E4%BB%A3%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">6.5 代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#651-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86"><span class="toc-number">1.5.1.</span> <span class="toc-text">6.5.1 何时使用代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#652-%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.2.</span> <span class="toc-text">6.5.2 创建代理对象</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/learn/java/core-java/learn-1/" rel="bookmark" title="原书笔记（卷一 1，2，3章）">原书笔记（卷一 1，2，3章）</a></li><li><a href="/learn/java/core-java/learn-4/" rel="bookmark" title="原书笔记（卷一 第4章）">原书笔记（卷一 第4章）</a></li><li><a href="/learn/java/core-java/learn-5/" rel="bookmark" title="原书笔记（卷一 第5章）">原书笔记（卷一 第5章）</a></li><li class="active"><a href="/learn/java/core-java/learn-6/" rel="bookmark" title="原书笔记（卷一 第6章）">原书笔记（卷一 第6章）</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Jalen Chu" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Jalen Chu</p><div class="description" itemprop="description">٩(●˙▿˙●)۶…⋆ฺ -></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">700</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">100</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">210</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NpbmNlcmVseVVuaXF1ZQ==" title="https:&#x2F;&#x2F;github.com&#x2F;SincerelyUnique"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9qYWxlbl9jaHU=" title="https:&#x2F;&#x2F;twitter.com&#x2F;jalen_chu"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qYWxlbmNodQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;jalenchu"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvbXkvbS9tdXNpYy9wbGF5bGlzdD9pZD0yMDMxOTczNDY0" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;my&#x2F;m&#x2F;music&#x2F;playlist?id&#x3D;2031973464"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS9KYWxlbkNodQ==" title="https:&#x2F;&#x2F;about.me&#x2F;JalenChu"><i class="ic i-address-card"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjExNTIzNTc0NzlAcXEuY29t" title="mailto:1152357479@qq.com"><i class="ic i-envelope"></i></span> <span class="exturl item facebook" data-url="aHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL2phbGVuLmNodS43OTIv" title="https:&#x2F;&#x2F;www.facebook.com&#x2F;jalen.chu.792&#x2F;"><i class="ic i-facebook"></i></span> <span class="exturl item stackoverflow" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS91c2Vycy8xMTExNzYxOC9qYWxlbi1jaHU=" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;11117618&#x2F;jalen-chu"><i class="ic i-stack-overflow"></i></span> <span class="exturl item youtube" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vY2hhbm5lbC9VQ3FQRnVtUGpGMWVRdVJrdWp0NUR1YWc=" title="https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCqPFumPjF1eQuRkujt5Duag"><i class="ic i-youtube"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li><li class="item"><a href="/webstack/" rel="section"><i class="ic i-user"></i>网址</a></li><li class="item dropdown"><a href="/html/%E5%9C%88%E5%B0%8F%E7%8C%AB.html" rel="section"><i class="ic i-tags"></i>玩耍</a><ul class="submenu"><li class="item"><a href="/html/%E5%9C%88%E5%B0%8F%E7%8C%AB.html" rel="section"><i class="ic i-tags"></i>圈小猫</a></li><li class="item"><a href="/html/%E6%92%95%E6%B8%94%E7%BD%91.html" rel="section"><i class="ic i-tags"></i>撕渔网</a></li><li class="item"><a href="/html/%E5%BD%A9%E8%99%B9%E9%9B%A8.html" rel="section"><i class="ic i-tags"></i>彩虹雨</a></li><li class="item"><a href="/html/%E6%96%B9%E5%9D%97%E7%A9%BF%E6%A2%AD.html" rel="section"><i class="ic i-tags"></i>方块穿梭</a></li><li class="item"><a href="/html/%E7%83%9F%E8%8A%B1%E6%95%88%E6%9E%9C.html" rel="section"><i class="ic i-tags"></i>烟花效果</a></li><li class="item"><a href="/html/%E7%A2%B0%E6%92%9E%E5%B0%8F%E7%90%83.html" rel="section"><i class="ic i-tags"></i>碰撞小球</a></li><li class="item"><a href="/html/%E7%BA%B8%E9%A3%9E%E6%9C%BA.html" rel="section"><i class="ic i-tags"></i>纸飞机</a></li><li class="item"><a href="/html/%E9%AA%87%E5%AE%A2%E5%B8%9D%E5%9B%BD.html" rel="section"><i class="ic i-tags"></i>骇客帝国</a></li><li class="item"><a href="/html/%E7%8E%AB%E7%91%B0%E8%8A%B1.html" rel="section"><i class="ic i-tags"></i>玫瑰花</a></li><li class="item"><a href="/html/%E9%97%AE%E9%97%AE%E9%A2%98.html" rel="section"><i class="ic i-tags"></i>问问题</a></li></ul></li><li class="item"><a href="/html/resume/index.html" rel="section"><i class="ic i-th"></i>简历</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/learn/java/core-java/learn-5/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/learn/devops/docker/centos-docker%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/learn/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/principle/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/principle/HeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 HeadFirst 设计模式">HeadFirst 设计模式</a></div><span><a href="/learn/principle/head-first-design-pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" title="工厂模式之工厂方法模式">工厂模式之工厂方法模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learn/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/frontent/" title="分类于 前端知识学习">前端知识学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/frontent/JQuery/" title="分类于 JQuery">JQuery</a></div><span><a href="/learn/frontent/jquery/JQuery%E8%AD%A6%E5%91%8A%20-%20Duplicated%20jQuery%20selector/" title="JQuery警告 - Duplicated jQuery selector">JQuery警告 - Duplicated jQuery selector</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learn/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/devops/" title="分类于 DevOPS">DevOPS</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/devops/Ubuntu/" title="分类于 Ubuntu">Ubuntu</a></div><span><a href="/learn/devops/ubuntu/Ubuntu%E6%97%A0%E6%B3%95%E8%8E%B7%E5%BE%97%E9%94%81/" title="Ubuntu无法获得锁">Ubuntu无法获得锁</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learn/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/database/" title="分类于 数据库学习">数据库学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/database/Redis/" title="分类于 Redis">Redis</a></div><span><a href="/learn/database/redis/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bhashes%E3%80%81sets%E5%92%8Csorted%20sets/" title="redis数据类型hashes、sets和sorted sets">redis数据类型hashes、sets和sorted sets</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learn/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/Java-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" title="分类于 Java 语言学习">Java 语言学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/java/Java/" title="分类于 Java">Java</a></div><span><a href="/learn/java/java-basic/java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0-Lambda/" title="java8新特性学习-Lambda">java8新特性学习-Lambda</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/life/" title="分类于 生活">生活</a> <i class="ic i-angle-right"></i> <a href="/categories/life/%E5%B8%B8%E8%AF%86/" title="分类于 常识">常识</a></div><span><a href="/life/nous/%E5%88%86%E6%9E%90%E9%94%80%E5%94%AE%E4%B8%9A%E7%BB%A9%E5%8F%97%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F%E7%9A%84%E5%BD%B1%E5%93%8D/" title="分析销售业绩受计算方式的影响">分析销售业绩受计算方式的影响</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/" title="分类于 二进制杂谈">二进制杂谈</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/Theme-Shoka-Documentation/" title="分类于 Theme Shoka Documentation">Theme Shoka Documentation</a></div><span><a href="/computer-science/note/theme-shoka-doc/display/" title="Step.3 界面显示">Step.3 界面显示</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learn/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/Java-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" title="分类于 Java 语言学习">Java 语言学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/java/GoogleGuava/" title="分类于 GoogleGuava">GoogleGuava</a></div><span><a href="/learn/java/google-guava/learn-10/" title="Cache类（2）">Cache类（2）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learn/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/Python-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" title="分类于 Python 语言学习">Python 语言学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learn/python/Python/" title="分类于 Python">Python</a></div><span><a href="/learn/python/python-basic/py3%20centos%E6%8A%A5%E9%94%99ModuleNotFoundError%20No%20module%20named%20%E2%80%98MySQLdb%E2%80%98/" title="py3 centos报错ModuleNotFoundError No module named ‘MySQLdb‘">py3 centos报错ModuleNotFoundError No module named ‘MySQLdb‘</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/table%E5%88%97%E5%AE%BD%E6%8B%96%E6%8B%BD/" title="table列宽拖拽">table列宽拖拽</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Jalen Chu @ Jalen's Blog</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">2m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">29:45</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"learn/java/core-java/learn-6/",favicon:{show:"（●´3｀●）復活成功",hide:"(´Д｀)瀏覽器崩潰啦"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:{placeholder:"1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪"},fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?908585f2e8b845b564946752e587f4a0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/z16.model.json"},display:{position:"left",width:200,height:400},mobile:{show:!0},react:{opacity:.7}})</script></body></html>